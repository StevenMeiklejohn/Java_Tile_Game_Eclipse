package com.codeclan;

import java.awt.Graphics;
import java.awt.image.BufferStrategy;

//notes. A thread is effectively a mini program within a program.
//We use the main program to create the window, canvas, etc and the thread
//handles our game inside its own mini programme. We can run a class seperately from the main programme.
//implements runnable, allows the class to run on a thread.

public class Game implements Runnable {
	
	private Display display;
	public String title;
	public int width;
	public int height;
	
	private Thread thread;
	
//	BufferStrategy tells the computer how to draw things to the screen.
//	Using memory buffers prevents the game flickering as it would if we were to draw directly to the screen.
	private BufferStrategy bs;
	private Graphics g;
	
	
	private boolean running = false;
	
	public Game(String title, int width, int height){
		this.title = title;
		this.width = width;
		this.height = height;
		
	}
	
//	The run method runs init once.
//	It sets up the graphics and other assets of our game.
	private void init(){
		display = new Display(title, width, height);
		
	}
	
	
//	Create update method for game loop.
	private void update(){
		
	}
	
//	Create render method for game loop.
	private void render(){
//		get how many buffers our strategy is going to use.
		bs = display.getCanvas().getBufferStrategy();
//		Check buffer strategy exists, and if not create one.
		if(bs == null){
			display.getCanvas().createBufferStrategy(3);
			return;
		}
		
//		create paintbrush.
		g = bs.getDrawGraphics();
//		clear the screen
		g.clearRect(0, 0, width, height);
//		draw here
//		g.fillRect(0, 0, width, height);
//		end drawing
		
		g.drawRect(10, 50, 50, 70);
		
//		draw to the canvas
		bs.show();
//		properly dispose of paintbrush.
		g.dispose();
		
	}
	
	
//	All classes which implement runnable must implement a run() method.
//	thread.start() initiates this method.
	public void run(){
		
		init();
		
//		Create the game loop. Update variables, positions of objects, states.
//		Render/redraw to the screen. Repeat.
		
		while(running){
			update();
			render();
		}
		stop();
		
	}
	
//	synchronized is used when starting or stopping a thread to ensure nothing gets messed up.
	
	public synchronized void start(){
//		Ensure game is not already running.
		if(running){
			return;
		}
//		Set running boolean to true
		running = true;
//		run thread by passing in Game class (which implements runnable)
		thread = new Thread(this);
//		kicks off run method.
		thread.start();
	}
	
//	Properly close down the thread.
	public synchronized void stop(){
//		Ensure game is not already stopped.
		if(!running){
			return;
		}
		running = false;
		try {
			thread.join();
		} catch (InterruptedException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
	}
	
	

}
